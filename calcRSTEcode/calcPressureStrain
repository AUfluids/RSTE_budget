/*---------------------------------------------------------------------------*\
License
    This file is part of RSTE_budget.

    RSTE_budget is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RSTE_budget is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with RSTE_budget. 
    If not, see <http://www.gnu.org/licenses/>.
/*---------------------------------------------------------------------------*\

FunctionObject
    Foam::calcPressureStrainTerm

Description
    Computes the pressure-strain correlation tensor term Phi_ij_RSTE from mean fields

Fields required
    - UMean            : Mean velocity field (volVectorField)
    - pMean            : Mean pressure field (volScalarField)
    - pGradUMean       : Pressure times mean velocity gradient (volTensorField)

Fields written
    - Phi_ij_RSTE      : Pressure-strain tensor (volSymmTensorField)

Example usage in controlDict:
\verbatim
functions
{
    #include "calcRSTEcode/calcPressureStrainTerm"
}
\endverbatim

SourceFile
    calcPressureStrainTerm

Authors
    2025  Christoffer Hansen & Mario Javier Rincon

\*---------------------------------------------------------------------------*/

calcPressureStrainTerm
{
    name            calcPressureStrainTerm;
    type            coded;
    libs            ("libutilityFunctionObjects.so");
    enabled         true;
    log             true;
    timeStart       $startTimeFieldAverage;
    timeEnd         $endTime;
    executeControl  adjustableRunTime;
    executeInterval $writeInterval;
    writeControl    adjustableRunTime;
    writeInterval   $writeInterval;

    codeOptions     #{ -I$(LIB_SRC)/OpenFOAM/lnInclude -I$(LIB_SRC)/finiteVolume/lnInclude #};

    codeWrite
    #{
        #include "fvCFD.H"

        // Field names
        const word UMeanName      = "UMean";
        const word pMeanName      = "pMean";
        const word pGradUMeanName = "pGradUMean";
        const word outputPhiij    = "Phi_ij_RSTE";        
        
        Info<< "Calculating Pressure-Strain (from means) Term for FO: " << this->name() << " at t=" << mesh().time().timeName() << endl;

        // Loading UMean
        if (!mesh().foundObject<volVectorField>(UMeanName))
        {
            FatalErrorInFunction << "Input field " << UMeanName << " not found for FO " << this->name() << "."
                << exit(FatalError);
        }
        const volVectorField& UMean = mesh().lookupObject<volVectorField>(UMeanName);
        Info<< "  Using input UMean field: " << UMean.name() << endl;

        // Loading pMean
        if (!mesh().foundObject<volScalarField>(pMeanName))
        {
            FatalErrorInFunction << "Input field " << pMeanName << " not found for FO " << this->name() << "."
                << exit(FatalError);
        }
        const volScalarField& pMean = mesh().lookupObject<volScalarField>(pMeanName);
        Info<< "  Using input pMean field: " << pMean.name() << endl;

        // Loading pGradUMean
        if (!mesh().foundObject<volTensorField>(pGradUMeanName))
        {
            FatalErrorInFunction << "Input field " << pGradUMeanName << " not found for FO " << this->name() << "."
                << exit(FatalError);
        }
        const volTensorField& pGradUMean = mesh().lookupObject<volTensorField>(pGradUMeanName);
        Info<< "  Using input pGradUMean field: " << pGradUMean.name() << endl;


        Info<< "  Calculating Sij_mean = symm(fvc::grad(UMean))" << endl;
        volSymmTensorField Sij_mean = symm(fvc::grad(UMean));

        Info<< "  Calculating pSij_mean = symm(pGradUMean)" << endl;
        volSymmTensorField pSij_mean = symm(pGradUMean);

        Info<< "  Calculating " << outputPhiij << " = pMean * Sij_mean" << endl;
        volSymmTensorField Phiij (IOobject(outputPhiij, mesh().time().timeName(), mesh(), IOobject::NO_READ, IOobject::AUTO_WRITE),
            2.0 * (pSij_mean - pMean * Sij_mean));

        Phiij.correctBoundaryConditions();
        Phiij.write();
    
        Info << "  Written symmTensor field: " << Phiij.name() << endl;
        Info<< endl;
    #};
}