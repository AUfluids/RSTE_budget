/*---------------------------------------------------------------------------*\
License
    This file is part of RSTE_budget.

    RSTE_budget is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RSTE_budget is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with RSTE_budget. 
    If not, see <http://www.gnu.org/licenses/>.
/*---------------------------------------------------------------------------*\

FunctionObject
    Foam::calcViscousDiffusionTerm

Description
    Computes the viscous diffusion tensor term D_ij_RSTE with wall boundary treatment

Fields required
    - UPrime2Mean      : Reynolds stress tensor field (volSymmTensorField)
    - transportProperties : Transport properties dictionary

Fields written
    - D_ij_RSTE        : Viscous diffusion tensor (volSymmTensorField)

Example usage in controlDict:
\verbatim
functions
{
    #include "calcRSTEcode/calcViscousDiffusionTerm"
}
\endverbatim

SourceFile
    calcViscousDiffusionTerm

Authors
    2025  Christoffer Hansen & Mario Javier Rincon

\*---------------------------------------------------------------------------*/

calcViscousDiffusionTerm
{
    type            coded;
    libs            ("libutilityFunctionObjects.so");
    enabled         true;
    log             true;
    timeStart       $startTimeFieldAverage;
    timeEnd         $endTime;
    executeControl  adjustableRunTime;
    executeInterval $writeInterval;
    writeControl    adjustableRunTime;
    writeInterval   $writeInterval;

    codeOptions     #{ -I$(LIB_SRC)/OpenFOAM/lnInclude -I$(LIB_SRC)/finiteVolume/lnInclude #};

    codeInclude     #{ #include "wallFvPatch.H" #};

    // --- Inputs ---
    RMeanName           UPrime2Mean;
    transportProperties transportProperties;

    // --- Output ---
    OutputName          D_ij_RSTE;

    name                calcDij;

    codeWrite
    #{
        #include "fvCFD.H"

        const word RMeanNameIn      = this->dict().lookupOrDefault<word>("RMeanName", "UPrime2Mean");
        const word transportPropsNm = this->dict().lookupOrDefault<word>("transportProperties", "transportProperties");
        const word viscDiffOutNm    = this->dict().lookupOrDefault<word>("OutputName", "D_ij_RSTE");

        Info<< "Calculating Viscous Diffusion Term for FO: " << this->name() << " at t=" << mesh().time().timeName() << endl;

        // Get nu
        if (!mesh().foundObject<IOdictionary>(transportPropsNm))
        {
            FatalErrorInFunction << "Transport properties '" << transportPropsNm << "' not found." << exit(FatalError);
        }
        const dictionary& transportProps = mesh().lookupObject<IOdictionary>(transportPropsNm);
        dimensionedScalar nu("nu", dimViscosity, transportProps);

        // Lookup RMean
        if (!mesh().foundObject<volSymmTensorField>(RMeanNameIn))
        {
            FatalErrorInFunction << "Field " << RMeanNameIn << " not found." << exit(FatalError);
        }
        const volSymmTensorField& RMean = mesh().lookupObject<volSymmTensorField>(RMeanNameIn);
        Info<< "  Inputs: " << RMean.name() << ", nu=" << nu << endl;

        volSymmTensorField D_ij_RSTE (
            IOobject(viscDiffOutNm, mesh().time().timeName(), mesh(), IOobject::NO_READ, IOobject::AUTO_WRITE),
            nu * fvc::laplacian(RMean)
        );

        const vectorField& cellCentres = mesh().C();
        const vectorField& faceCentres = mesh().Cf();

        forAll(mesh().boundary(), patchI)
        {
            const fvPatch& patch = mesh().boundary()[patchI];

            if (isA<wallFvPatch>(patch))
            {
                const label startFaceI = patch.start();
                const labelList& faceCells = patch.faceCells();

                forAll(faceCells, faceI)
                {
                    const label c0 = faceCells[faceI];
                    const label meshFaceI = startFaceI + faceI;

                    const point faceCenter = faceCentres[meshFaceI];
                    const vector normal = (cellCentres[c0] - faceCenter) / mag(cellCentres[c0] - faceCenter);

                    const labelList& nbrs = mesh().cellCells()[c0];
                    //Info << "Cell " << c0 << " (" << patch.name() << ") has " << nbrs.size() << " neighbors." << endl;

                    label bestNbr = -1;
                    scalar maxProj = -GREAT;

                    for (const label nbr : nbrs)
                    {
                        const vector d = cellCentres[nbr] - faceCenter;
                        scalar proj = d & normal;

                        //Info << "    Neighbor " << nbr << " projection: " << proj << endl;

                        if (proj > maxProj)
                        {
                            maxProj = proj;
                            bestNbr = nbr;
                        }
                    }

                    if (bestNbr != -1)
                    {
                        D_ij_RSTE[c0] = D_ij_RSTE[bestNbr];
                        //Info << "  Overwriting cell " << c0
                        //     << " from neighbor " << bestNbr
                        //     << " with projection " << maxProj << endl;
                    }
                    else
                    {
                        //Info << "  WARNING: No valid neighbor found for cell " << c0
                        //     << " on patch " << patch.name() << endl;
                    }
                }
            }
        }

        D_ij_RSTE.correctBoundaryConditions();
        D_ij_RSTE.write();

        Info<< "  Written field: " << D_ij_RSTE.name() << endl;
        Info<< endl;
    #};
}
