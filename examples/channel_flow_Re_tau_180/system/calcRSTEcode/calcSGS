/*---------------------------------------------------------------------------*\
License
    This file is part of RSTE_budget.

    RSTE_budget is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RSTE_budget is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with RSTE_budget. 
    If not, see <http://www.gnu.org/licenses/>.
/*---------------------------------------------------------------------------*\

FunctionObject
    Foam::calcSGS

Description
    Computes the subgrid-scale (SGS) stress tensor term SGS_ij_RSTE for LES-RSM budgets

Fields required
    - divNutSijUMean       : Divergence term from LES model (volTensorField)
    - divNutSijMean_UMean  : Mean SGS divergence term (volTensorField)

Fields written
    - SGS_ij_RSTE          : Subgrid-scale tensor (volSymmTensorField)

Preceding field operation:
\verbatim
divNutSijMean_UMean
{
    type        multiply;
    libs        ("libfieldFunctionObjects.so");
    fields      (divNutSijMean UMean);     
    result      divNutSijMean_UMean;    
    enabled     true;
    log         false;
    timeStart   $startTimeFieldAverage;
    timeEnd     $endTime;
    executeControl adjustableRunTime;
    executeInterval $writeInterval;
    writeControl none;
}
\endverbatim

Example usage in controlDict:
\verbatim
functions
{
    #include "calcRSTEcode/divNutSijMean_UMean"
    #include "calcRSTEcode/calcSGS"
}
\endverbatim

SourceFile
    calcSGS

Authors
    2025  Christoffer Hansen & Mario Javier Rincon

\*---------------------------------------------------------------------------*/

divNutSijMean_UMean
{
    type            multiply;
    libs            ("libfieldFunctionObjects.so");
    fields          (divNutSijMean UMean);     
    result          divNutSijMean_UMean;   
    enabled         true;
    log             false;
    timeStart       $startTimeFieldAverage;
    timeEnd         $endTime;
    executeControl  adjustableRunTime;
    executeInterval $writeInterval;
    writeControl    none;
}

calcSGS
{
    name            calcSGS;
    type            coded;
    libs            ("libutilityFunctionObjects.so");
    enabled         true;
    log             true;
    timeStart       $startTimeFieldAverage;
    timeEnd         $endTime;
    executeControl  adjustableRunTime;
    executeInterval $writeInterval;
    writeControl    adjustableRunTime;
    writeInterval   $writeInterval;
    
    // Basic includes
    codeOptions
    #{ -I$(LIB_SRC)/OpenFOAM/lnInclude -I$(LIB_SRC)/finiteVolume/lnInclude #}; 

    // --- Input(s) ---
    UMeanName                UMean;
    divNutSijMeanName        divNutSijMean;
    divNutSijUMeanName    divNutSijUMean;

    // --- Output(s) ---
    OutputName      SGS_ij_RSTE;

    // Code for calculating SGS term
    codeWrite
    #{
        #include "fvCFD.H"

        // Input-Output namelist
        const word divNutSijUMeanNameIn   = this->dict().lookupOrDefault<word>("divNutSijUMeanName", "divNutSijUMean");
        const word divNutSijMean_UMeanNameIn = this->dict().lookupOrDefault<word>("divNutSijMean_UMeanName", "divNutSijMean_UMean");
        const word sgsOutNm                  = this->dict().lookupOrDefault<word>("OutputName", "SGS_ij_RSTE");

        Info<< "Calculating SGS Term for FO: " << this->name() << " at t=" << mesh().time().timeName() << endl;

        // ----- Reading Input variables ----- //
    
        // Lookup divNutSijUMean
        if (!mesh().foundObject<volTensorField>(divNutSijUMeanNameIn)) { FatalErrorInFunction << "Field " << divNutSijUMeanNameIn << " not found." << exit(FatalError); }
        const volTensorField& divNutSijUMean = mesh().lookupObject<volTensorField>(divNutSijUMeanNameIn);

        // Lookup divNutSijMean_UMean
        if (!mesh().foundObject<volTensorField>(divNutSijMean_UMeanNameIn)) { FatalErrorInFunction << "Field " << divNutSijMean_UMeanNameIn << " not found." << exit(FatalError); }
        const volTensorField& divNutSijMean_UMean = mesh().lookupObject<volTensorField>(divNutSijMean_UMeanNameIn);

        Info<< "  Inputs: " << divNutSijUMean.name() << ", " << divNutSijMean_UMean.name() << endl;

        // ----- Preparing Output ----- //

        // Constructing SGS as a volSymmTensor 
        volSymmTensorField SGS_ij_RSTE
        (
            IOobject(sgsOutNm, mesh().time().timeName(), mesh(), IOobject::NO_READ, IOobject::AUTO_WRITE),
            2.0 * symm(2.0 * divNutSijUMean) - 2.0 * symm(2.0 * divNutSijMean_UMean)
        );

        // Writing Output
        SGS_ij_RSTE.correctBoundaryConditions();
        SGS_ij_RSTE.write();

        Info<< "  Written field: " << SGS_ij_RSTE.name() << endl;
        Info<< endl;
    #};
}